[Active Record Validations] 액티브 레코드 밸리데이션(검증)
=========================

본 가이드에서는 객체의 상태를 검증하는 방법을 알려준 뒤 객체를 테이터베이스에 저장할 때 액티브 레코드의 검증하는 기능을 알려줍니다. [[[This guide teaches you how to validate the state of objects before they go into the database using Active Record's validations feature.]]]

본 가이드를 읽은 후에는 아래와 같은 내용을 할 수 있을 것입니다. [[[After reading this guide, you will know:]]]

* 액티브 레코드 밸리데이션(검증) 헬퍼(매크로) 사용법 [[[How to use the built-in Active Record validation helpers.]]]

* 여러분이 만든 밸리데이션(검증) 메소드를 만드는 방법 [[[How to create your own custom validation methods.]]]

* 밸리데이션(검증) 과정의 에러 메시지를 처리하는 방법 [[[How to work with the error messages generated by the validation process.]]]

--------------------------------------------------------------------------------

[Validations Overview] 밸리데이션 개요
--------------------

밸리데이션에 대한 짧은 코드 [[[Here's an example of a very simple validation:]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```

위에서 보듯이, 밸리데이션은 `Person`에 `name` 요소가 없으면 옳지 않습니다. 따라서 두번째 `Person`를 데이터베이스에 저장하지 않겠습니다. [[[As you can see, our validation lets us know that our `Person` is not valid without a `name` attribute. The second `Person` will not be persisted to the database.]]]

더 진행하기에 앞서 밸리데이션이 전반적으로 애플리케이션에 맞는지 살펴보겠습니다. [[[Before we dig into more details, let's talk about how validations fit into the big picture of your application.]]]

### [Why Use Validations?] 밸리데이션을 사용하는 이유? 

밸리데이션은 올바른 데이터만 데이타베이스에 저장하도록 합니다. 예를 들어, 애플리케이션의 중요한 점음 모든 사용자가 올바른 이메일 주소와 메일링 주소를 입력하도록 하는 것입니다. 모델-수준의 밸리데이션이  올바른 데이타만 데이터베이스에 저장하는 최선의 방법입니다. 모델-수준의 밸리데이션은 데이터베이스와 무관하며, 일반 사용자는 우회할 수 없고, 테스트하고 유지하는데 편리합니다. 레일스는 밸리데이션을 쉽게 사용할 수 있고, 공통적으로 필요한 헬퍼 메소드가 내장되어 있고, 여러분이 직접 밸리데이션 메소드를 만들 수 있습니다. [[[Validations are used to ensure that only valid data is saved into your database. For example, it may be important to your application to ensure that every user provides a valid email address and mailing address. Model-level validations are the best way to ensure that only valid data is saved into your database. They are database agnostic, cannot be bypassed by end users, and are convenient to test and maintain. Rails makes them easy to use, provides built-in helpers for common needs, and allows you to create your own validation methods as well.]]]

데이타를 데이터베이스에 저장하기 전에 데이터를 밸리데이션하는 다른 방법 몇가지가 있는데, 테이터베이스의 제약조건을 쓰거나, 클라이언트에서 밸리데이션하거나, 콘트롤러-수준의 밸리데이션이 있습니다. 장단점은 아래와 같습니다. [[[There are several other ways to validate data before it is saved into your database, including native database constraints, client-side validations, controller-level validations. Here's a summary of the pros and cons:]]]

* 데이터베이스 제약조건과 내장 프로시저는 데이터베이스에 맞춘 밸리데이션 동작원리이므로 테스트하거나 유지하기가 점점 어려워질 수 있습니다. 한편, 테이터베이스를 다른 애플리케이션에서도 사용한다면, 데이터베이스 수준에서 제약조건 몇개를 적용해도 좋다고 봅니다. 그리고 테이터베이스-수준의 밸리데이션은 매주 자주 사용하는 테이블의 유일한 값 같은 것들을 처리할 수 있으며 다른 방법으로는 밸리데이션을 만들기 어렵습니다. [[[Database constraints and/or stored procedures make the validation mechanisms database-dependent and can make testing and maintenance more difficult. However, if your database is used by other applications, it may be a good idea to use some constraints at the database level. Additionally, database-level validations can safely handle some things (such as uniqueness in heavily-used tables) that can be difficult to implement otherwise.]]]

* 클라이언트에서의 밸리데이션은 유용할 수 있지만, 보통 클라이언트 밸리데이션만 사용하지 않습니다. 밸리데이션을 자바스크립트로 만들면 밸리데이션을 통과하는 방법은 브라우저에서 자바스크립트 사용을 멈추면 됩니다. 그러나 자바스크립트와 다른 방법를 같이 쓴다면 웹사이트 사용자에게 밸리데이션 결과를 바로 보여줄 수 있습니다. [[[Client-side validations can be useful, but are generally unreliable if used alone. If they are implemented using JavaScript, they may be bypassed if JavaScript is turned off in the user's browser. However, if combined with other techniques, client-side validation can be a convenient way to provide users with immediate feedback as they use your site.]]]

* 콘트롤러-수준의 밸리데이션은 처음에 바로 써버리기 쉽상이지만, 코드가 길어지고 테스트와 유지가 어렵습니다. 가능하다면, 콘틀로러는 코드가 간결하도록 하는 편이 좋으며, 결국엔 작업하기에 편하겠습니다. [[[Controller-level validations can be tempting to use, but often become unwieldy and difficult to test and maintain. Whenever possible, it's a good idea to keep your controllers skinny, as it will make your application a pleasure to work with in the long run.]]]

위의 밸리데이션은 특정한 경우에 선택합니다. 레일스 팀은 모델-수준의 밸리데이션이 대부분의 경우에 적합하다고 생각합니다. [[[Choose these in certain, specific cases. It's the opinion of the Rails team that model-level validations are the most appropriate in most circumstances.]]]

### [When Does Validation Happen?] 밸리데이션은 언제 하는가?

액티브 레코드 객체는 두 종류가 있습니다: 데이터베이스에 있는 것 하나와 없는 것 하나입니다. `new` 메소드로 객체를 생성한 직후, 객체는 아직 데이터베이스에 저장하지 않았습니다. 객체에 `save` 메소드를 실행해야 객체를 해당 데이블에 저장합니다. 액티브 레코드는 인스턴스 메소드인 `new_record?`를 실행하여 객체가 데이트베이스에도 저장되어 있는지 확인합니다. 아래와 같은 액티브 레코드 클래스를 보겠습니다. [[[There are two kinds of Active Record objects: those that correspond to a row inside your database and those that do not. When you create a fresh object, for example using the `new` method, that object does not belong to the database yet. Once you call `save` upon that object it will be saved into the appropriate database table. Active Record uses the `new_record?` instance method to determine whether an object is already in the database or not. Consider the following simple Active Record class:]]]

```ruby
class Person < ActiveRecord::Base
end
```

어떻게 동작하는지 `rails console` 실행결과를 봅니다. [[[We can see how it works by looking at some `rails console` output:]]]

```ruby
$ rails console
>> p = Person.new(name: "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
```

레코드를 생성하여 저장할 때 테이터베이스로 SQL `INSERT`문을 전달하여 실행합니다. 기존의 레코드를 수정할 때는 수정하는 SQL `UPDATE` 문을 전달하여 실행합니다. 일반적으로 밸리데이션 실행한 후 명령문을 테이터베이스로 전달합니다. 밸리데이션 중에 하나라도 통과하지 못하면, 객체가 부적합하다고 표시하여 액티브 레코드가 `INSERT`나 `UPDATE`를 실행하지 않습니다. 그 결과 데이터베이스에 부적합 객체를 저장하지 않도록 합니다. 밸리데이션을 실행하는 경우는 새로 만들 때, 저장할 때, 수정할 때 입니다. [[[Creating and saving a new record will send an SQL `INSERT` operation to the database. Updating an existing record will send an SQL `UPDATE` operation instead. Validations are typically run before these commands are sent to the database. If any validations fail, the object will be marked as invalid and Active Record will not perform the `INSERT` or `UPDATE` operation. This avoids storing an invalid object in the database. You can choose to have specific validations run when an object is created, saved, or updated.]]]

CAUTION: 테이터베이스에 있는 객체의 상태를 바꾸는 방법이 많습니다. 밸리데이션을 실행하는 메소드가 있는 반면에 그렇지 않은 메소드도 있습니다. 즉, 여러분이 주의하지 않으면 부적합 상태의 객체를 저장할 수 있습니다. [[[There are many ways to change the state of an object in the database. Some methods will trigger validations, but some will not. This means that it's possible to save an object in the database in an invalid state if you aren't careful.]]]

아래의 메소드는 밸리데이션을 실행하며, 객체가 적합할 때만 테이터베이스에 객체를 저장합니다. [[[The following methods trigger validations, and will save the object to the database only if the object is valid:]]]

* `create`
* `create!`
* `save`
* `save!`
* `update`
* `update!`

느낌표가 붙은 메소드(예. `save!`)는 레코드가 부적합이면 예외가 발생합니다. 느낌표가 붙지 않는 메소드는 예외가 발생하지 않습니다: `save` 와 `update` 메소드는 `false`를 반환하고, `create` 는 객체를 반환합니다. [[[The bang versions (e.g. `save!`) raise an exception if the record is invalid. The non-bang versions don't: `save` and `update` return `false`, `create` just return the objects.]]]

### [Skipping Validations] 밸리데이션 무시하는 방법

아래의 메소드는 밸리데이션을 실행하지 않아서, 객체의 적합여부를 떠나 테이터베이스에 객체를 저장하겠습니다. 주의해서 사용해야겠습니다. [[[The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.]]]

* `decrement!`
* `decrement_counter`
* `increment!`
* `increment_counter`
* `toggle!`
* `touch`
* `update_all`
* `update_attribute`
* `update_column`
* `update_columns`
* `update_counters`

덧붙여서 `save` 메소드는 위와 같이 밸리데이션을 실행하지 않을 수 있는데 `validate: false`를 인자로 넘겨주면 됩니다. 이러한 방법은 주의해서 사용해야 합니다. [[[Note that `save` also has the ability to skip validations if passed `validate: false` as argument. This technique should be used with caution.]]]

* `save(validate: false)`

### [`valid?` and `invalid?`] `valid?` 와 `invalid?` 

레일스는 객체 적합 여부를 판별하려고 `valid?` 메소드를 사용합니다. 여러분이 각자 메소드를 만들 수도 있습니다. `valid?` 메소드는 밸리데이션을 실행하고 객체에 에러가 없어야 참값을 반환합니다. 앞서 보았듯이: [[[To verify whether or not an object is valid, Rails uses the `valid?` method. You can also use this method on your own. `valid?` triggers your validations and returns true if no errors were found in the object, and false otherwise. As you saw above:]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```

액티브 레코드가 밸리데이션을 실행한 결과, 발견된 하나 이상의 에러를 읽어오려면 인스턴스 메소드인 `errors` 를 실행할 수 있으며, 에러를 담은 자료구조를 반환합니다. 정의에 따르면 밸리데이션 실행결과 에러를 담은 자료구조가 비어 있으면 객체는 적합입니다. [[[After Active Record has performed validations, any errors found can be accessed through the `errors` instance method, which returns a collection of errors. By definition, an object is valid if this collection is empty after running validations.]]]

기술적으로 부적합하더라도 `new` 메소드로 객체를 만들면 에러를 알려주지 않습니다. `new` 메소드를 사용할 때 밸리데이션을 실행하지 않기 때문입니다. [[[Note that an object instantiated with `new` will not report errors even if it's technically invalid, because validations are not run when using `new`.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true
end

>> p = Person.new
#=> #<Person id: nil, name: nil>
>> p.errors
#=> {}

>> p.valid?
#=> false
>> p.errors
#=> {name:["can't be blank"]}

>> p = Person.create
#=> #<Person id: nil, name: nil>
>> p.errors
#=> {name:["can't be blank"]}

>> p.save
#=> false

>> p.save!
#=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

>> Person.create!
#=> ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```

`invalid?` 메소드는 `valid?` 메소드와 정반대입니다. `invalid?` 메소드는 밸리데이션을 실행하고, 객체에 에러를 하나라도 발견하면 참값을 반환합니다. [[[`invalid?` is simply the inverse of `valid?`. It triggers your validations, returning true if any errors were found in the object, and false otherwise.]]]

### `errors[]`

객체에 대한 어떤 속성이 올바른지 확인하려면, `errors[:attribute]`를 사용할 수 있습니다. 실해결과 `:속성`에 대한 모든 에러를 배열로 반환합니다. 에러가 없으면 빈 배열을 반환합니다. [[[To verify whether or not a particular attribute of an object is valid, you can use `errors[:attribute]`. It returns an array of all the errors for `:attribute`. If there are no errors on the specified attribute, an empty array is returned.]]]

 [[[This method is only useful _after_ validations have been run, because it only
inspects the errors collection and does not trigger validations itself. It's
different from the `ActiveRecord::Base#invalid?` method explained above because
it doesn't verify the validity of the object as a whole. It only checks to see
whether there are errors found on an individual attribute of the object.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true
end

>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true
```

밸리데이션 에러를 [밸리데이션 에러 처리](#working-with-validation-errors)에서 자세히 살펴보겠습니다. 이제부터 레일스에 들어 있는 밸리데이션 헬퍼 메소드를 살펴보겠습니다. [[[We'll cover validation errors in greater depth in the [Working with Validation Errors](#working-with-validation-errors) section. For now, let's turn to the built-in validation helpers that Rails provides by default.]]]

[Validation Helpers] 밸리데이션 헬퍼(메소드)
------------------

액티브 렉코드는 미리 만들어둔 헬퍼 메소드가 여러 개 있어서 클래스를 정의할 때 바로 쓸 수 있습니다. 헬퍼는 공공의 밸리데이션 규칙을 제공합니다. 밸리데이션이 통과하지 못할 때 마다, 객체의 `errors` 배열에 에러 메시지를 담아서, 밸리데이션을 적용한 속성과 메시지를 연결합니다. [[[Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers provide common validation rules. Every time a validation fails, an error message is added to the object's `errors` collection, and this message is associated with the attribute being validated.]]]

헬퍼는 속성 이름의 임시 번호를 받아서, 같은 밸리데이션을 속성 여러 개에 한 줄로 추가할 수 있습니다. [[[Each helper accepts an arbitrary number of attribute names, so with a single line of code you can add the same kind of validation to several attributes.]]]

모든 속성에는 `:on`과 `:message` 옵션이 있고, 각 옵션은 언제 밸리데이션을 실행하고 어떤 메시지를 `errors` 배열에 넣을지 정합니다. `:on` 옵션에는 `:save` (기본 옵션), `:create`, `:update` 중 한가지입니다. 밸리데이션 헬퍼는 각각 에러 메시지가 있습니다. `:message` 옵션이 없으면 이미 정해둔 에러 메시지를 사용합니다. 사용가능한 헬퍼를 하나씩 살펴보겠습니다. [[[All of them accept the `:on` and `:message` options, which define when the validation should be run and what message should be added to the `errors` collection if it fails, respectively. The `:on` option takes one of the values `:save` (the default), `:create`  or `:update`. There is a default error message for each one of the validation helpers. These messages are used when the `:message` option isn't specified. Let's take a look at each one of the available helpers.]]]

### `acceptance`

`acceptance` 헬퍼는 사용자 폼을 서버로 전송할 때 유저 인터페이스에서 체크박스를 선택했는지 확인합니다. 주로 사용하는 예로 웹사이트 사용 약관을 동의하거나 당부사항 등을 읽었음을 확인할 때 입니다. 이러한 밸리데이션은 웹사이트에는 매우 당연하고 '사용자 동의'는 데이타 베이스 어딘가에 저장하려고 하지 않아도 됩니다(사용자 동의에 대한 테이블 항목이 없으면, 헬퍼는 가상 속성을 만듭니다).[[[This method validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application's terms of service, confirm reading some text, or any similar concept. This validation is very specific to web applications and this 'acceptance' does not need to be recorded anywhere in your database (if you don't have a field for it, the helper will just create a virtual attribute).]]]

```ruby
class Person < ActiveRecord::Base
  validates :terms_of_service, acceptance: true
end
```

기본 에러 메시지는 _"00를 동의해야 합니다."_(_"must be accepted"_) 입니다. [[[The default error message for this helper is _"must be accepted"_.]]]

`:accept` 옵션을 사용하면, 값을 지정할 수 있습니다. 기본값은 "1"이고 다른 값으로 지정할 수 있습니다. [[[It can receive an `:accept` option, which determines the value that will be considered acceptance. It defaults to "1" and can be easily changed.]]]

```ruby
class Person < ActiveRecord::Base
  validates :terms_of_service, acceptance: { accept: 'yes' }
end
```

### `validates_associated`

`validates_associated` 헬퍼는 모델 사이에 관계에 대해서 검증합니다. 객체를 저장할 때, 객체와 연관된 다른 객체의 `valid?` 를 실행합니다. [[[You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, `valid?` will be called upon each one of the associated objects.]]]

```ruby
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
```

모든 관계 유형에 적용할 수 있습니다. [[[This validation will work with all of the association types.]]]

CAUTION: `validates_associated` 을 관계를 맺은 양쪽 모두에 사용해서는 안됩니다. 양쪽이 서로 밸리데이션을 실행해서 무한히 반복하기 때문입니다.[[[Don't use `validates_associated` on both ends of your associations. They would call each other in an infinite loop.]]]

기본 에러 메시지는 _"유효하지 않습니다."_(_"is invalid"_) 입니다. 한가지 짚고 넘어갈 것은 관계를 맺은 객체마다 `errors` 배열이 있어서 밸리데이션을 실행하는 모델에 에러를 쌓지 않습니다. [[[The default error message for `validates_associated` is _"is invalid"_. Note that each associated object will contain its own `errors` collection; errors do not bubble up to the calling model.]]]

### `confirmation`

`confirmation` 헬퍼는 텍스트 필드 두 개가 서로 내용이 같아야 할 때 사용해야 합니다. 예를 들어, 이메일 주소 또는 비밀번호를 사용자가 틀리지 않게 입력하지 않도록 재확인하도록 합니다. 이 밸리데이션은 재확인해야할 속성의 이름 뒤에 "_confirmed"을 붙여서 가상의 속성을 추가합니다. [[[You should use this helper when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with "_confirmation" appended.]]]

```ruby
class Person < ActiveRecord::Base
  validates :email, confirmation: true
end
```

뷰 템플릿은 아래와 같다고 가정하면, [[[In your view template you could use something like]]]

```erb
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```

`email_confirmation`은 `nil` 이 아닌지 검사합니다. 재확인하도록 하려면, 확인할 속성에 값이 있는지 확인하는 검사를 추가해야 합니다(나중에 `presence`에서 살펴보겠습니다). [[[This check is performed only if `email_confirmation` is not `nil`. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at `presence` later on this guide):]]]

```ruby
class Person < ActiveRecord::Base
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```

기본 에러 메시지는 _"입력한 내용과 서로 다릅니다"_(_"doesn't match confirmation"_) 입니다. [[[The default error message for this helper is _"doesn't match confirmation"_.]]]

### `exclusion`

`exclusion` 헬퍼는 속성의 값이 어떤 집합에 없는지 검증합니다. 집합은 객체를 나열할 수 있습니다. [[[This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.]]]

```ruby
class Account < ActiveRecord::Base
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "Subdomain %{value} is reserved." }
end
```

`exclusion` 헬퍼는 `:in` 옵션이 있어서 올바른 속성이 받을 수 있는 값에 대한 집합을 보낼 수 있습니다. `:in` 옵션은 별칭으로 `:within`이 있고, 똑같이 사용할 수 있습니다. 위의 예시 코드는 `:message` 옵션을 써서 속성을 값을 보여줍니다. [[[The `exclusion` helper has an option `:in` that receives the set of values that will not be accepted for the validated attributes. The `:in` option has an alias called `:within` that you can use for the same purpose, if you'd like to. This example uses the `:message` option to show how you can include the attribute's value.]]]

기본 에러 메시지는 _"이미 가지고 있습니다"_(_"is reserved"_) 입니다. [[[The default error message is _"is reserved"_.]]]

### `format`

`format` 헬퍼는 속성 값을 정규표현식으로 비교하고, 정규표현식은 `:with` 옵션 뒤에 씁니다. [[[This helper validates the attributes' values by testing whether they match a given regular expression, which is specified using the `:with` option.]]]

```ruby
class Product < ActiveRecord::Base
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "Only letters allowed" }
end
```

기본 에러 메시지는 _"유효하지 않습니다."(_"is invalid"_) 입니다. [[[The default error message is _"is invalid"_.]]]

### `inclusion`

`inclusion` 속성 값이 어떤 집합에 있는지 검증합니다. 집합은 객체를 나열할 수 있습니다. [[[This helper validates that the attributes' values are included in a given set. In fact, this set can be any enumerable object.]]]

```ruby
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
```

`inclusion` 헬퍼는 `:in` 옵션이 있어서 속성이 받을 수 있는 값에 대한 집합을 보낼 수 있습니다. `:in` 옵션은 별칭으로 `:within`이 있고, 똑같이 사용할 수 있습니다. 위의 예시 코드는 `:message` 옵션을 써서 속성을 값을 보여줍니다. [[[The `inclusion` helper has an option `:in` that receives the set of values that will be accepted. The `:in` option has an alias called `:within` that you can use for the same purpose, if you'd like to. The previous example uses the `:message` option to show how you can include the attribute's value.]]]

기본 에러 메시지는 _"목록에 없습니다"_(_"is not included in the list"_) 입니다. [[[The default error message for this helper is _"is not included in the list"_.]]]

### `length`

`length` 헬퍼는 속성 값의 길이/크기를 검증합니다. 옵션이 여러 개 있어서, 길이/크기에 대한 여러 가지 조건을 걸 수 있습니다. [[[This helper validates the length of the attributes' values. It provides a variety of options, so you can specify length constraints in different ways:]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
```

길이/크기에 대한 제약 조건은 아래와 같습니다: [[[The possible length constraint options are:]]]

* `:minimum` - 속성에 대한 가장 작은 길이/크기 [[[The attribute cannot have less than the specified length.]]]

* `:maximum` - 속성에 대한 가장 큰 길이/크기 [[[The attribute cannot have more than the specified length.]]]

* `:in` (or `:within`) - 속성 길이/크기에 대한 범위. 옵션은 범위로 표현해야 합니다. [[[The attribute length must be included in a given interval. The value for this option must be a range.]]]

* `:is` - `:is` 뒤에 나온 값과 같아야 합니다. [[[The attribute length must be equal to the given value.]]]

기본 에러 메시지는 길이/크기에 따라 다릅니다. 메시지에 대한 옵션은 `:wrong_length`, `:too_long`, `:too_short`가 있고 옵션 안에 `%{count}`로 제한하는 길이/크기를 보여줍니다. `:message` 옵션으로도 에러 메시지를 보여줄 수 있습니다. [[[The default error messages depend on the type of length validation being performed. You can personalize these messages using the `:wrong_length`, `:too_long`, and `:too_short` options and `%{count}` as a placeholder for the number corresponding to the length constraint being used. You can still use the `:message` option to specify an error message.]]]

```ruby
class Person < ActiveRecord::Base
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
```

보통 길이/크기는 글자수를 세지만, 다른 방법으로 셀 수 있는데 `:tokenizer` 옵션을 써서 값을 나눌 수 있습니다: [[[This helper counts characters by default, but you can split the value in a different way using the `:tokenizer` option:]]]

```ruby
class Essay < ActiveRecord::Base
  validates :content, length: {
    minimum: 300,
    maximum: 400,
    tokenizer: lambda { |str| str.scan(/\w+/) },
    too_short: "must have at least %{count} words",
    too_long: "must have at most %{count} words"
  }
end
```

기본 에러 메시지는 대상이 복수형입니다(예, "is too short (minimum is %{count} characters)"). 따라서, `:minimun`이 1이라면 메시지를 별도로 만들거나 `presence: true` 를 사용합니다. `:in` 또는 `:within` 의 가장 작은 값이 1이라면, 메시지를 별도로 만들거나 `length` 앞에 `presence`를 사용합니다. [[[Note that the default error messages are plural (e.g., "is too short (minimum is %{count} characters)"). For this reason, when `:minimum` is 1 you should provide a personalized message or use `presence: true` instead. When `:in` or `:within` have a lower limit of 1, you should either provide a personalized message or call `presence` prior to `length`.]]]

`size` 헬퍼는 `length`의 별칭입니다. [[[The `size` helper is an alias for `length`.]]]

### `numericality`

`numericality` 헬퍼는 [[[This helper validates that your attributes have only numeric values. By default, it will match an optional sign followed by an integral or floating point number. To specify that only integral numbers are allowed set `:only_integer` to true.]]]

`:only_integer` 옵션을 `true` 로 설정하면, [[[If you set `:only_integer` to `true`, then it will use the]]]

```ruby
/\A[+-]?\d+\Z/
```

위와 같은 정규표현식으로 속성 값을 검증합니다. 옵션을 따로 정하지 않으면 `Float`으로 속성 값의 데이타 타입 바꾸려고 합니다. [[[regular expression to validate the attribute's value. Otherwise, it will try to convert the value to a number using `Float`.]]]

WARNING. 위와 같은 정규표현식은 줄바꿈 문자가 뒤따라 올 수 있습니다. [[[Note that the regular expression above allows a trailing newline character.]]]

```ruby
class Player < ActiveRecord::Base
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
```

`:only_integer` 옵션 외에도, 제약 조건을 걸 수 있는 옵션은 아래와 같습니다: [[[Besides `:only_integer`, this helper also accepts the following options to add constraints to acceptable values:]]]

* `:greater_than` - 이 옵션 뒤에 오는 수치/숫자보다 커야 합니다. 기본 에러 메시지는 _"%{count}보다 커야 합니다"_(_"must be greater than %{count}"_) 입니다. [[[Specifies the value must be greater than the supplied value. The default error message for this option is _"must be greater than %{count}"_.]]]

* `:greater_than_or_equal_to` - 이 옵션 뒤에 오는 수치/숫자보다 같거나 커야 합니다. 기본 에러 메시지는 _"%{count}와 같거나 보다 커야 합니다"_(_"must be greater than or equal to %{count}"_) 입니다. [[[Specifies the value must be greater than or equal to the supplied value. The default error message for this option is _"must be greater than or equal to %{count}"_.]]]

* `:equal_to` - 이 옵션 뒤에 오는 수치/숫자와 같아야 합니다. 기본 에러 메시지는 _"%{count}와 같아야 합니다"_(_"must be equal to %{count}"_) 입니다. [[[Specifies the value must be equal to the supplied value. The default error message for this option is _"must be equal to %{count}"_.]]]

* `:less_than` - 이 옵션 뒤에 오는 수치/숫자보다 적어야 합니다. 기본 에러 메시지는 _"%{count}보다 적어야 합니다"_(_"must be less than %{count}"_) 입니다. [[[Specifies the value must be less than the supplied value. The default error message for this option is _"must be less than %{count}"_.]]]

* `:less_than_or_equal_to` - 이 옵션 뒤에 오는 수치/숫자보다 같거나 적어야 합니다. 기본 에러 메시지는 _"%{count}와 같거나 보다 적어야 합니다"_(_"must be less than or equal to %{count}"_) 입니다. [[[Specifies the value must be less than or equal the supplied value. The default error message for this option is _"must be less than or equal to %{count}"_.]]]

* `:odd` - 속성 값이 홀수인지 검사하려면 true로 설정합니다. 기본 에러 메시지는 _"홀수만 됩니다"_(_"must be odd"_) 입니다. [[[Specifies the value must be an odd number if set to true. The default error message for this option is _"must be odd"_.]]]

* `:even` - 속성 값이 홀수인지 검사하려면 true로 설정합니다. 기본 에러 메시지는 _"짝수만 됩니다"_(_"must be even"_) 입니다. [[[Specifies the value must be an even number if set to true. The default error message for this option is _"must be even"_.]]]

기본 에러 메시지는 _"에 숫자를 입력해 주세요"_(_"is not a number"_) 입니다. [[[The default error message is _"is not a number"_.]]]


### `presence`

`presence` 헬퍼는 속성이 비어 있는지 검증합니다. `blank?` 메소드는 `nil` 또는 문자열 비어있는지 검사하고, 여기서 비어있는 문자열은 내용이 없거나 빈칸으로만 채워진 문자열을 말합니다. [[[This helper validates that the specified attributes are not empty. It uses the `blank?` method to check if the value is either `nil` or a blank string, that is, a string that is either empty or consists of whitespace.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, :login, :email, presence: true
end
```

모델 관계가 존재한다고 검증하려면, 관계를 나타내기 위해 외부 참조 키 대신에 관계를 맺은 객체가 있는지 검사할 필요가 있습니다. [[[If you want to be sure that an association is present, you'll need to test whether the associated object itself is present, and not the foreign key used to map the association.]]]

```ruby
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
end
```

관계를 맺은 레코드가 존재한다면, 관계를 쓸 때 `:inverse_of` 옵션을 뒤따라 써야 합니다. [[[In order to validate associated records whose presence is required, you must specify the `:inverse_of` option for the association:]]]

```ruby
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
```

`has_one` 또는 `has_many` 관계로 맺은 객체에 대해 존재하는지 검증할 때, 객체가 `blank?` 도 아니고 `marked_for_destruction?` 도 아닌지 검사합니다.  [[[If you validate the presence of an object associated via a `has_one` or `has_many` relationship, it will check that the object is neither `blank?` nor `marked_for_destruction?`.]]]

`false.blank?` 결과는 true 이라서 , 부울린 값은 `validates :field_name, inclusion: { in: [true, false] }` 이와 같이 써야 합니다. [[[Since `false.blank?` is true, if you want to validate the presence of a boolean field you should use `validates :field_name, inclusion: { in: [true, false] }`.]]]

기본 에러 메시지는 _"에 내용을 입력해 주세요"_ (_"can't be empty"_) 입니다. [[[The default error message is _"can't be empty"_.]]]

### `absence`

`absence`헬퍼는 헬퍼 뒤에 쓰는 속성의 내용이 비어 있는지 검증합니다. `present?` 메소드를 써서 속성 값이 nil 이거나 비어 있는 문자열인지 검사합니다. [[[This helper validates that the specified attributes are absent. It uses the `present?` method to check if the value is not either nil or a blank string, that is, a string that is either empty or consists of whitespace.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, :login, :email, absence: true
end
```

모델 관계가 존재하지 않는다고 검증하려면, 관계를 나타내기 위해 외부 참조 키 대신에 관계를 맺은 객체가 존재하지 않는지 검사할 필요가 있습니다. [[[If you want to be sure that an association is absent, you'll need to test whether the associated object itself is absent, and not the foreign key used to map the association.]]]

```ruby
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, absence: true
end
```

관계로 맺은 객체에 대해 존재하지 않는지 검증할 때, 관계를 쓸 때 `:inverse_of` 옵션을 뒤따라 써야 합니다. [[[In order to validate associated records whose absence is required, you must specify the `:inverse_of` option for the association:]]]

```ruby
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
```

`has_one` 또는 `has_many` 관계로 맺은 객체에 대해 존재하지 않는지 검증할 때, 객체가 `present?` 도 아니고 `marked_for_destruction?` 도 아닌지 검사합니다. [[[If you validate the absence of an object associated via a `has_one` or `has_many` relationship, it will check that the object is neither `present?` nor `marked_for_destruction?`.]]]

`false.present?` 결과는 false 이라서, 부울린 값은 `validates :field_name, exclusion: { in: [true, false] }` 이와 같이 써야 합니다. [[[Since `false.present?` is false, if you want to validate the absence of a boolean field you should use `validates :field_name, exclusion: { in: [true, false] }`.]]]

기본 에러 메시지는 _"비어 있어야 합니다"_(_"must be blank"_) 입니다. [[[The default error message is _"must be blank"_.]]]

### `uniqueness`

`uniqueness` 헬퍼는 객체를 저장하기 전에 속성 값이 중복되지 않는지 검증합니다. 헬퍼는 데이타베이스의 제약조건을 만들지 않으므로, 데이타베이스 연결이 달라서 중복되지 않도록 설정한 테이블 컬럼 값이 같은 레코드가 두개 만들 수도 있습니다. 중복되는 경우를 예방하기 위해, 데이터베이스에서 인덱스를 만들어야 합니다. [[[This helper validates that the attribute's value is unique right before the object gets saved. It does not create a uniqueness constraint in the database, so it may happen that two different database connections create two records with the same value for a column that you intend to be unique. To avoid that, you must create a unique index in your database.]]]

```ruby
class Account < ActiveRecord::Base
  validates :email, uniqueness: true
end
```

밸리데이션 동작하면 모델의 테이블로 SQL 쿼리를 실행하고, 속성의 같은 값이 있는 레코드가 있는지 검색합니다. [[[The validation happens by performing an SQL query into the model's table, searching for an existing record with the same value in that attribute.]]]

`:scope` 옵션 뒤에 검증할 속성 여러 개를 나열합니다: [[[There is a `:scope` option that you can use to specify other attributes that are used to limit the uniqueness check:]]]

```ruby
class Holiday < ActiveRecord::Base
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end
```

`:case_sensitive` 옵션은 대문자를 구분합니다. 따로 정하지 않아도 옵션은 켜져 있습니다. [[[There is also a `:case_sensitive` option that you can use to define whether the uniqueness constraint will be case sensitive or not. This option defaults to true.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, uniqueness: { case_sensitive: false }
end
```

WARNING. 어떤 데이터베이스는 대문자를 구별하지 않고 검색하도록 설정되어 있습니다. [[[Note that some databases are configured to perform case-insensitive searches anyway.]]]

기본 에러 메시지는 _"이미 있습니다"_(_"has already been taken"_) 입니다. [[[The default error message is _"has already been taken"_.]]]

### `validates_with`

`validates_with` 헬퍼는 밸리데이션에 대한 클래스를 정할 수 있습니다. [[[This helper passes the record to a separate class for validation.]]]

```ruby
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
```

NOTE: `record.errors[:base]`에 레코드 상태에 대한 모든 에러를 추가하지만, 속성에 대해서는 추가하지 않습니다. [[[Errors added to `record.errors[:base]` relate to the state of the record as a whole, and not to a specific attribute.]]]

`validates_with` 헬퍼 뒤에 밸리데이션을 사용하는 클래스 하나가 올 수도 있고 클래스 여러 개가 올 수도 있습니다. `validates_with`는 기본 에러 메시지가 없습니다. 레코드의 에러 배열에 에러를 직접 추가해야 합니다. [[[The `validates_with` helper takes a class, or a list of classes to use for validation. There is no default error message for `validates_with`. You must manually add errors to the record's errors collection in the validator class.]]]

밸리데이트 메소드의 코드를 작성하려면, 검증할 `record` 파라미터를 정해야합니다. [[[To implement the validate method, you must have a `record` parameter defined, which is the record to be validated.]]]

다른 밸리데이션과 같이, `validates_with`는 `:if`, `:unless`, `:on` 옵션이 있습니다. 다른 옵션이 있다면, 검증하는 클래스에 `options` 로 옵션을 전달합니다: [[[Like all other validations, `validates_with` takes the `:if`, `:unless` and `:on` options. If you pass any other options, it will send those options to the validator class as `options`:]]]

```ruby
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end

class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
```

밸리데이터는 애플리케이션을 종료하기 전까지 *한번만* 생성하기 때문에, 인스턴스 변수를 사용할 때 주의해야 합니다. [[[Note that the validator will be initialized *only once* for the whole application life cycle, and not on each validation run, so be careful about using instance variables inside it.]]]

밸리데이터가 인스턴스 변수를 사용할 정도로 복잡해지면, 예전 방식으로 루비 객체를 대신 사용할 수 있습니다: [[[If your validator is complex enough that you want instance variables, you can easily use a plain old Ruby object instead:]]]

```ruby
class Person < ActiveRecord::Base
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end
  
  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "This person is evil"
    end
  end
  
  # …
end
```

### `validates_each`

`validates_each` 헬퍼는 검증할 속성을 블록으로 처리합니다. 미리 정해둔 검증 메소드는 없습니다. 블록을 하나 만들고, `validate_each` 에 속성을 전달하여 검사합니다. 아래의 예시에서는, 이름과 성씨의 첫글자가 소문자가 아닌지 검사합니다. [[[This helper validates attributes against a block. It doesn't have a predefined validation function. You should create one using a block, and every attribute passed to `validates_each` will be tested against it. In the following example, we don't want names and surnames to begin with lower case.]]]

```ruby
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end
```

블록에 레코드, 속성 이름과 속성의 값을 전달합니다. 블록 안에서 올바른 데이타를 검사할 수 있습니다. 밸리데이션을 통과하지 못하면, 모델에 에러 메시지를 추가하고 부적합으로 표시합니다. [[[The block receives the record, the attribute's name and the attribute's value. You can do anything you like to check for valid data within the block. If your validation fails, you should add an error message to the model, therefore making it invalid.]]]

[Common Validation Options] 공통으로 사용하는 밸리데이션 옵션
-------------------------

공통으로 사용하는 옵션은 아래와 같습니다: [[[These are common validation options:]]]

### `:allow_nil`

`:allow_nil` 옵션은 `nil`이 오더라도 밸리데이션을 통과합니다. [[[The `:allow_nil` option skips the validation when the value being validated is `nil`.]]]

```ruby
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end
```

### `:allow_blank`

`:allow_blank` 옵션은 `:allow_nil`과 비슷합니다. 이 옵션은 속성 값이 `nil` 또는 비어있는 문자열과 같이 `blank?`이라도 밸리데이션을 통과합니다. [[[The `:allow_blank` option is similar to the `:allow_nil` option. This option will let validation pass if the attribute's value is `blank?`, like `nil` or an empty string for example.]]]

```ruby
class Topic < ActiveRecord::Base
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create("title" => "").valid?  # => true
Topic.create("title" => nil).valid? # => true
```

### `:message`

앞서 살펴보았듯이, `:message` 옵션은 밸리데이션을 통과하지 못할 때 `errors` 배열에 넣을 메시지를 정합니다. 이 옵션이 없으면, 액티브 레코드는 밸리데이션 헬퍼의 기본 에러 메시지를 사용합니다. [[[As you've already seen, the `:message` option lets you specify the message that will be added to the `errors` collection when validation fails. When this option is not used, Active Record will use the respective default error message for each validation helper.]]]

### `:on`

`:on` 옵션은 밸리데이션을 실행할 시점을 정합니다. 액티브 레코드에 들어있는 밸리데이션 헬퍼는 저장할 때 실행합니다(레코드를 새로 만들 때와 내용을 수정할 때 모두). 밸리데이션을 실행할 시점을 바꾸려면, `on: :create` 과 같이 레코드를 새로 만들 때만 실행하거나, `on: :update` 와 같이 레코드의 내용을 수정할 때만 밸리데이션을 실행할 수 있습니다. [[[The `:on` option lets you specify when the validation should happen. The default behavior for all the built-in validation helpers is to be run on save(both when you're creating a new record and when you're updating it). If you want to change it, you can use `on: :create` to run the validation only when a new record is created or `on: :update` to run the validation only when a record is updated.]]]

```ruby
class Person < ActiveRecord::Base
  # it will be possible to update email with a duplicated value
  validates :email, uniqueness: true, on: :create

  # it will be possible to create the record with a non-numerical age
  validates :age, numericality: true, on: :update

  # the default (validates on both create and update)
  validates :name, presence: true, on: :save
end
```
마지막 코드는 지금까지는 검토 단계이고, 레일스 버전이 3.2.x 에서는 동작하지 않습니다. [이슈](https://github.com/rails/rails/issues/10248)를 참고바랍니다. [[[The last line is in review state and as of now, it is not running in any version of Rails 3.2.x as discussed in this [issue](https://github.com/rails/rails/issues/10248)]]]

[Strict Validations] 엄격한 밸리데이션
------------------

밸리데이션을 통과하지 못할 때 `ActiveModel::StrictValidationFailed` 예외를 발생시킵니다. [[[You can also specify validations to be strict and raise `ActiveModel::StrictValidationFailed` when the object is invalid.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: { strict: true }
end

Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank
```

`:strict` 옵션 뒤에 발생시킬 에외를 정할 수 있습니다. [[[There is also an ability to pass custom exception to `:strict` option]]]

```ruby
class Person < ActiveRecord::Base
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # => TokenGenerationException: Token can't be blank
```

[Conditional Validation] 밸리데이션 분기 
----------------------

간혹 특정 조건에 따라 객체를 검증하는 편이 좋을 때가 있습니다. `:if`와 `:unless` 옵션을 사용할 수 있으며, 옵션 뒤에는 심볼, 문자열, `Proc`, `Array`가 올 수 있습니다. `:if` 옵션을 사용할 때는 밸리데이션을 ***반드시*** 실행할 때입니다. 밸리데이션을 반드시 실행하지 ***아니*** 할 때는 `:unless` 옵션을 사용합니다. [[[Sometimes it will make sense to validate an object only when a given predicate is satisfied. You can do that by using the `:if` and `:unless` options, which can take a symbol, a string, a `Proc` or an `Array`. You may use the `:if` option when you want to specify when the validation **should** happen. If you want to specify when the validation **should not** happen, then you may use the `:unless` option.]]]

### [Using a Symbol with `:if` and `:unless`] `:if`와 `:unless` 뒤에 심볼을 사용하는 방법

`:if`와 `:unless` 옵션 뒤에 메소드 이름을 심볼로 써서 밸리데이션을 실행하기 전에 메소드를 실행할 수 있습니다. 주로 쓰는 방법입니다. [[[You can associate the `:if` and `:unless` options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.]]]

```ruby
class Order < ActiveRecord::Base
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
```

### [Using a String with `:if` and `:unless`] `:if`와 `:unless` 뒤에 문자열을 사용하는 방법

문자열은 `eval`로 루비 코드를 실행할 수 있습니다. 문자열은 매우 짧은 코드를 쓸 때만 이 옵션을 사용해야 합니다. [[[You can also use a string that will be evaluated using `eval` and needs to contain valid Ruby code. You should use this option only when the string represents a really short condition.]]]

```ruby
class Person < ActiveRecord::Base
  validates :surname, presence: true, if: "name.nil?"
end
```

### [Using a Proc with `:if` and `:unless`] `:if`와 `:unless` 뒤에 프록을 사용하는 방법

끝으로, `:if`와 `:unless` 옵션 뒤에 `Proc` 객체를 써서 실행할 수 있습니다. `Proc` 객체를 메소드를 따로 만들지 않고 조건을 쓸 수 있습니다. 한 줄로 쓸 때 적절합니다. [[[Finally, it's possible to associate `:if` and `:unless` with a `Proc` object which will be called. Using a `Proc` object gives you the ability to write an inline condition instead of a separate method. This option is best suited for one-liners.]]]

```ruby
class Account < ActiveRecord::Base
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end
```

### [Grouping Conditional validations] 조건 하나로 밸리데이션 여러 개를 묶는 방법

간혹 여러 가지 검증을 한 가지 조건으로 실행하려고 할 때 유용한 방법으로 `with_options`를 사용할 수 있습니다. [[[Sometimes it is useful to have multiple validations use one condition, it can be easily achieved using `with_options`.]]]

```ruby
class User < ActiveRecord::Base
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end
```

`if: :is_admin?` 조건에 따라 `with_options` 블록 안에 있는 모든 밸리데이션이 차례대로 통과합니다. [[[All validations inside of `with_options` block will have automatically passed the condition `if: :is_admin?`]]]

### [Combining Validation Conditions] 밸리데이션 조건을 이어서 쓰는 방법

반대로, 밸리데이션을 실행할 조건이 여러 개 라면, `Array`를 사용할 수 있습니다. 그리고, `:if`와 `:unless`를 동시에 같은 밸리데이션에 이어서 쓸 수 있습니다. [[[On the other hand, when multiple conditions define whether or not a validation should happen, an `Array` can be used. Moreover, you can apply both `:if` and `:unless` to the same validation.]]]

```ruby
class Computer < ActiveRecord::Base
  validates :mouse, presence: true,
                    if: ["market.retail?", :desktop?]
                    unless: Proc.new { |c| c.trackpad.present? }
end
```

`:if` 옵션 뒤에 오는 조건과 `:unless` 옵션 뒤에 오는 조건 모두 결과가 `true` 이어야 밸리데이션을 실행합니다. [[[The validation only runs when all the `:if` conditions and none of the `:unless` conditions are evaluated to `true`.]]]

[Performing Custom Validations] 밸리데이션을 만들어서 실행하는 방법
-----------------------------

액티브 레코드가 만들어 둔 밸리데이션으로 충분하지 않을 때, 여러분이 원하는 대로 밸리데이션 클래스 또는 밸리데이션 메소드를 작성할 수 있습니다. [[[When the built-in validation helpers are not enough for your needs, you can write your own validators or validation methods as you prefer.]]]

### [Custom Validators] 커스텀 밸리데이터

사용자가 만든 커스텀 밸리데이터는 `ActiveModel::Validator`를 상속받습니다. 이 클래스는 `validate` 메소드를 구현하며 메소드는 레코드를 파라미터로 받아서 레코드에 대한 밸리데이션을 실행합니다. `validates_with` 메소드 뒤에 클래스 이름을 써서 사용할 수 있습니다. [[[Custom validators are classes that extend `ActiveModel::Validator`. These classes must implement a `validate` method which takes a record as an argument and performs the validation on it. The custom validator is called using the `validates_with` method.]]]

```ruby
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end

class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
```

속성마다 커스텀 밸리데이터를 적용해서 밸리데이션하는 쉬운 방법으로 `ActiveModel::EachValidator`를 사용합니다. 이 커스텀 밸리데이터 클래스는 `validate_each` 메소드를 구현하며 레코드, 속성, 속성 값 세 가지를 파라미터로 넘겨 받고, 속성과 속성 값을 검증합니다. [[[The easiest way to add custom validators for validating individual attributes is with the convenient `ActiveModel::EachValidator`. In this case, the custom validator class must implement a `validate_each` method which takes three arguments: record, attribute and value which correspond to the instance, the attribute to be validated and the value of the attribute in the passed instance.]]]

```ruby
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end

class Person < ActiveRecord::Base
  validates :email, presence: true, email: true
end
```

위의 예시 코드와 같이, email 밸리데이터를 만들어서 다른 밸리데이터와 함께 사용할 수 있습니다. [[[As shown in the example, you can also combine standard validations with your own custom validators.]]]

### [Custom Methods] 커스텀 메소드

모델의 상태를 검사하고 결과가 부적합일 때 `errors` 배열에 메시지를 넣는 메소드를 만들 수 있습니다. 메소드를 새로 만든 후 클래스 메소드인 `validate` 뒤에 메소드 이름을 심볼로 적으면 됩니다. [[[You can also create methods that verify the state of your models and add messages to the `errors` collection when they are invalid. You must then register these methods by using the `validate` class method, passing in the symbols for the validation methods' names.]]]

클래스 메소드 심볼을 여러 개 적을 수 있고 `validate` 클래스 메소드 뒤에 적은 순서대로 밸리데이션을 실행합니다. [[[You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.]]]

```ruby
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    if discount > total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end
```

밸리데이션을 실행할 시점을 정하지 않으면 `valid?` 메소드를 실행할 때마다 밸리데이션을 실행합니다. 실행할 시점을 정하려면 `validate` 메소드에서 `:on` 옵션 뒤에 `:create` 또는 `:update`를 쓸 수 있습니다. [[[By default such validations will run every time you call `valid?`. It is also possible to control when to run these custom validations by giving an `:on` option to the `validate` method, with either: `:create` or `:update`.]]]

```ruby
class Invoice < ActiveRecord::Base
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
```

[Working with Validation Errors] 밸리데이션 에러 처리
------------------------------

앞에서는 `valid?`와 `invalid?` 메소드를 살펴보았고, 레일스는 `errors` 배열를 사용하고 객체의 적합 여부를 물어보는 메소드들이 있습니다. [[[In addition to the `valid?` and `invalid?` methods covered earlier, Rails provides a number of methods for working with the `errors` collection and inquiring about the validity of objects.]]]

주로 사용하는 메소드는 순서대로 살펴보겠습니다. `ActiveModel::Errors` 다큐먼트를 참조하면 모든 메소드를 볼 수 있습니다. [[[The following is a list of the most commonly used methods. Please refer to the `ActiveModel::Errors` documentation for a list of all the available methods.]]]

### `errors`

`ActiveModel::Errors` 클래스를 반환하고 모든 에러를 담고 있습니다. 속성 이름을 키고 쓰고 키에 해당하는 값은 모든 에러를 문자열 배열로 담고 있습니다. [[[Returns an instance of the class `ActiveModel::Errors` containing all errors. Each key is the attribute name and the value is an array of strings with all errors.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors
 # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors # => []
```

### `errors[]`

`errors[]` 메소드는 속성 하나에 대해 에러 메시지를 가져옵니다. 한 속성에 대한 모든 에러 메시지를 문자열 배열로 반환하고, 문자열마다 에러 메시지가 한 개 있습니다. 해당 속성의 에러 메시지가 없으면 비어있는 배열을 반환합니다. [[[`errors[]` is used when you want to check the error messages for a specific attribute. It returns an array of strings with all error messages for the given attribute, each string with one error message. If there are no errors related to the attribute, it returns an empty array.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(name: "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```

### `errors.add`

`add` 메소드는 어떤 속성에 대한 에러 메시지를 추가합니다. `errors.full_messages` 또는 `errors.to_a` 메소드를 사용하면 사용자가 읽을 수 형태로 출력할 수 있습니다. 에러 메시지에서 속성 이름이 맨 앞에 오며 첫글자는 대문자입니다. `add` 메소드는 메시지에 넣을 속성 이름을 파라미터로 받습니다. [[[The `add` method lets you manually add messages that are related to particular attributes. You can use the `errors.full_messages` or `errors.to_a` methods to view the messages in the form they might be displayed to a user. Those particular messages get the attribute name prepended (and capitalized). `add` receives the name of the attribute you want to add the message to, and the message itself.]]]

```ruby
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
```

`add` 대신에 `[]=` 메소드를 사용해도 됩니다. [[[Another way to do this is using `[]=` setter]]]

```ruby
  class Person < ActiveRecord::Base
    def a_method_used_for_validation_purposes
      errors[:name] = "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(name: "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
```

### `errors[:base]`

속성 하나마다 에러 메시지를 넣을 수도 있지만 객체 상태의 전반적인 에러 메시지를 넣을 수도 있습니다. `errors[:base]` 메소드는 속성 값에 상관없이 객체가 부적합하다고 표시할 수 있습니다. `errors[:base]`는 배열이라서, 에러 메시지 문자열을 `<<`로 뒤에 붙일 수 있습니다. [[[You can add error messages that are related to the object's state as a whole, instead of being related to a specific attribute. You can use this method when you want to say that the object is invalid, no matter the values of its attributes. Since `errors[:base]` is an array, you can simply add a string to it and it will be used as an error message.]]]

```ruby
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
```

### `errors.clear`

`clear` 메소드는 `errors` 배열에 있는 모든 에러 메시지를 지울 때 사용합니다. 당연히, 부적합한 객체에 `errors.clear` 메소드를 실행하더라도 객체가 적합한 상태로 바뀌지 않습니다: `errors` 배열은 내용이 없더라도, `valid?` 메소드를 실행하거나 데이터베이스에 객체를 저장할 때 밸리데이션을 재실행합니다. 밸리데이션을 통과하지 못하면, `errors` 배열에 에러 메시지를 다시 채웁니다. [[[The `clear` method is used when you intentionally want to clear all the messages in the `errors` collection. Of course, calling `errors.clear` upon an invalid object won't actually make it valid: the `errors` collection will now be empty, but the next time you call `valid?` or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the `errors` collection will be filled again.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

p.save # => false

p.errors[:name]
# => ["can't be blank", "is too short (minimum is 3 characters)"]
```

### `errors.size`

`size` 메소드는 객체의 에러 메시지 수를 반환합니다. [[[The `size` method returns the total number of error messages for the object.]]]

```ruby
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.size # => 2

person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
```

[Displaying Validation Errors in Views] 밸리데이션 예러를 뷰에 보여주는 방법
-------------------------------------

모델을 만든 후 밸리데이션을 추가해버리면, HTML 폼으로 모델을 만들면, 통과하지 못한 밸리데이션의 에러 메시지를 사용자에게 보여주고 싶을 때가 있습니다. [[[Once you've created a model and added validations, if that model is created via a web form, you probably want to display an error message when one of the validations fail.]]]

이러한 경우 애플리케이션마다 처리하는 방법이 다르기 때문에, 레일스는 에러 메시지를 만들어 주는 뷰 헬퍼가 없습니다. 그러나, 레일스는 사용자와 밸리데이션을 주고 받을 수 있는 메소드가 많아서, 여러분이 직접 만들기 쉽습니다. 그리고, 스캐폴드 제너레이터를 실행하여 기본 틀이 되는 코드를 생성할 때, 레일스가 `_form.html.erb` 파일에 모델마다 에러 메시지를 전체를 보여주는 ERB 코드를 넣어줍니다. [[[Because every application handles this kind of thing differently, Rails does not include any view helpers to help you generate these messages directly. However, due to the rich number of methods Rails gives you to interact with validations in general, it's fairly easy to build your own. In addition, when generating a scaffold, Rails will put some ERB into the `_form.html.erb` that it generates that displays the full list of errors on that model.]]]

인스턴스 변수 이름이 `@post`인 모델을 저장한다면, 에러 메시지를 보여주는 코드는 아래와 같습니다: [[[Assuming we have a model that's been saved in an instance variable named `@post`, it looks like this:]]]

```ruby
<% if @post.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>

    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```

레일스의 폼 헬퍼 메소드로 HTML 폼 태그를 만들 때, 입력 필드의 밸리데이션 에러가 있으면, 해당 항목에 `<div>` 태그를 만들어 끼워 줍니다. [[[Furthermore, if you use the Rails form helpers to generate your forms, when a validation error occurs on a field, it will generate an extra `<div>` around the entry.]]]

```
<div class="field_with_errors">
 <input id="post_title" name="post[title]" size="30" type="text" value="">
</div>
```

field_with_errors의 div 태그의 스타일 속성은 바꿀 수 있습니다. 레일스가 만들어 주는 CSS는 아래와 같습니다: [[[You can then style this div however you'd like. The default scaffold that Rails generates, for example, adds this CSS rule:]]]

```
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}
```

이 CSS는 에러가 있는 입력 필드를 빨간 색의 2 픽셀 두께로 테두리를 그립니다. [[[This means that any field with an error ends up with a 2 pixel red border.]]]
